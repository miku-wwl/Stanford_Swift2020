# assigment_3 Memorize 期中作业
## Required Tasks
1. 实现一个单人游戏
2. 第一次运行时，不会出现任何卡牌，开始游戏后随机的从屏幕外飞入12张卡牌
3. 游戏的进行中，卡片应同时显示在屏幕上，而随着越来越多（或更少）出现在屏幕上，卡片应变得越来越小（或更大），同时始终使用尽可能多的可用空间， Grid可以完成所有这些工作，卡位置和/或大小的所有更改都必须进行动画处理
4. 卡片必须始终都具有相同的长宽比
5. 卡上的符号应与卡的尺寸成比例，即大卡大emoji，小卡较小emoji
6. 通过触摸3张牌就可以尝试出一组；显示出user已经选择过哪些卡片
7. 选择了3张卡之后，必须用样式表现出这3张卡是匹配还是不匹配。可以通过显示不同的颜色，边框，背景，动画等来实现，3张卡片中不匹配的那张要和另外两张区别样式
8. 只有1或2张卡的情况下，支持通过触摸已选择的卡来“取消选择”
9. 触摸任何一张卡后，并且已有3张matching Set cards里的卡
    a. 根据每个Set的规则，用卡组中的新卡替换这3张匹配的Set卡  
    b. 匹配的卡片随机飞到屏幕外  
    c. 替换卡应从屏幕外的位置飞入
    d. 如果卡座是空的，则应为其余卡提供匹配卡所腾出的空间（即卡片变大）  
    e. 如果触摸的卡不是matching Set cards的一部分，则选择该卡
10. 触摸任何卡并且已经选择了3张non-matching Set cards，取消选择这3张不匹配卡并选择触摸的那张卡
11. 需要有一个 “Deal 3 More Cards” 按钮
     a. 如果选定的牌组成一个Set，则更换触摸选定的卡
     b. 如果所选的卡未达成一个Set（或选择的卡少于3张，包括无卡），飞入3张新卡
     c. 如果卡座是空的，禁用此按钮
12. “NewGame”按钮开始新游戏，返回到12张随机选择的纸牌，交互动画依然是飞入废除
13. 可以将Set游戏中的“squiggle”外观替换为矩形
14. 必须编写自己的Shape结构来制作菱形。
15. 可以使用半透明的颜色来表示“条纹”阴影
16. 可以使用任何三种颜色，只要它们之间可以明显区分即可
17. 您必须使用 enum 作为解决方案的重要组成部分
18. 必须使用 closure 作为解决方案的重要组成部分
19. 保证不同设备的模拟器的portrait or landscape（横屏竖屏）都运行正常 

## Hints
1. 如果需要，可以随意使用Grid布置卡片。也可以根据需要对其进行修改，但这不太可能。 
2. 确保清楚考虑模型中的内容，ViewModel中的内容以及View中的内容。总是问自己“这是关于Set游戏如何进行或如何呈现的吗？” 
3. model应该清楚地显示甲板上所有或曾经有过的卡片的状态。投入一些工作来尝试为您的模型设计一个一致的API。 
4. 在View和ViewModel之间进行任何复杂性权衡时，请简化您的View。 
5. model并没有真正的复杂性“折衷”，因为它只是试图呈现一个与UI无关的编程界面，从而尽可能有效地发挥Set的作用。 ViewModel必须适应您模型的设计（如果model设计不错，那么对于ViewModel来说应该不太困难）。 
6. 视图始终是模型的反映。这是“反应式”，“声明式” UI编程。 Model发生变化，并且只根据Model的当前状态声明了View的外观（完全是通过View通过ViewModel访问的）。尝试摆脱可能已经长大的“命令式”编程模型（即调用一个函数，然后又发生某事，然后又调用另一个函数，而又发生了另一件事）。这不是我们在SwiftUI中做UI的方式。 
7. 沿着这些思路，正在进行的任何动画只是随着时间的推移向用户显示已经发生的事情。还要注意，不需要做任何“事情即将发生的动画”，就像我们为“记忆中的派”所做的那样。此Set应用程序中的所有动画都直接显示已经发生的事情（例如发牌，选择牌或匹配和丢弃牌）。 
8. 最好不要将诸如颜色甚至形状和阴影名称之类的“面向显示”的东西硬连接到模型中，这是一个很好的MVVM设计。想象一下，就像您为Memorize所做的那样，为游戏设置主题。
9. 以下是有关“ ﬂying”卡片的一些帮助
    a. “刷卡”的所有必需任务都只是在讨论表示从UI“来来去去”的卡的视图
    b. SwiftUI中“视图”的“来来去去”使用过渡进行动画处理（如本讲座所述）
    c. “飞走（或飞入）”只是在移动。从他们最终将要在屏幕上的位置移动到屏幕外的某个随机位置。因此需要在某处具有一个简单的功能，该功能可以计算屏幕外的随机位置（卡片可以在其中往返）
    d. 在SwiftUI中移动时有一个完美的过渡，称为AnyTransition.offset（CGSize）（可为View中的.offset修改器使用相同的ViewModifier动画）
    e. 确保将.transition修饰符放在实际上即将来临的View上，而不是放在该View内部的某些Stack上
    f. 除非您的模型清楚地表示游戏中当前涉及哪些牌，否则牌不会“来回走走”。已经发卡了吗？卡已经匹配并丢弃了吗？这样的事情必须在模型中的某个地方，否则UI将不知道在给定的时刻应该在屏幕上显示哪些卡片。 视图仅绘制模型的状态。因此如网格中的“可识别”数组（假设您正在使用它来显示卡）不会包含尚未处理或已被匹配并丢弃的卡
    h. 记住除非明确地设置动画，否则过渡动画不会发生。因此需要用户采取的任何操作，都可能导致使用withAnimation明确显示动画卡。 
    i. 不要忘记.onAppear。当UI首次出现在屏幕上时，让游戏继续进行可能非常有用
10. 请小心测试您的“最终游戏”（即当套牌用完时）。为了使测试更加容易，也许可​​以在测试模式下匹配任意3张纸牌。这样您就可以快速进入游戏结束。或在局部甲板上进行测试。 
11. 别忘了对所有的变量和函数设置适当的访问控制。
12. 此分配不需要将自定义动画添加到自定义ViewModifier或Shape中（即您须为此赋值编写的Shape没有任何自定义动画，并且您也不会编写自己的ViewModifier）。
13. 将某个View类型用于计算的var或作为函数的返回类型时，请回想一下要让Swift编译器查看代码内部，弄清楚实际返回的是哪种类型，并有效地将某些View替换为该类型（并确保该类型符合View）。这意味着返回的内容必须在编译时即可确定（而不是在运行时）。这就是使用ViewBuilder完成构建Views的“条件”的原因，以及为什么我们不能在返回某些View的函数的顶层执行ifelse或switch语句。因此，如果要返回某些View并在其中包含if-elses，请记住使用ViewBuilder（ViewBuilder不完全支持switch（至少在撰写本文时还不行），因此可能必须使用if-else）。 
14. 可能还会想从函数中返回一些Shape。几乎从来没有做过这件事，因为没有ShapeBuilder这样的东西（即诸如ViewBuilder for Shapes之类的东西）。相反，传递需要描边和/或填充Shape并从该函数返回一些View所需的信息。 
15. 这在本课程中几乎是一个“中期”，因此请花一些时间来确保到目前为止确实了解所有内容。该应用程序实际上并不需要使用全新的内容。如果无法使该应用程序正常运行，那么最终项目肯定会遇到麻烦。


## Things to Learn
1. 与作业1和2的所有内容几乎无关，这次需要从头开始
2. Access Control
3. Shape
4. Animation 
5. enum
6. Closures 

## Extra
1. 让卡从屏幕上某处的卡座视图中ﬂying飞入。这比选择“随机”到一个随机位置要困难得多，因为找出其他视图所在的位置将需要您进行一些调查。 
2. 如果从deck上进行发牌，则让卡片在deck上时“面朝下”，然后在发牌时将其滑出到其位置。 
3. 绘制实际的曲线图，而不是使用矩形。
4. 绘制实际的条纹“阴影”，而不是使用半透明的颜色。 
5. 当卡片匹配时，提供一些激动人心的动画。换句话说，使用动画来显示在“必需任务”中卡片是否匹配。
6. 使“离开”更加令人兴奋（也许卡片随着“离开”而旋转？）。
7. 在Set游戏中以某种方式保持得分。您可以决定哪种评分方式最有意义。
8. 给选择更快的组合更快的得分（即将时间成分纳入您的计分系统）。 
9. 弄清楚当实际选择一套时，如何惩罚选择多发3张牌的玩家。 
10. 在用户界面中添加“作弊”按钮。
11. 支持两个玩家。无需在这里过分。也许只是每个用户的一个按钮（可能是一个颠倒的屏幕顶部？），声称他们在板上看到了一个Set。然后，该玩家获得了（相当短的）时间来实际选择组合，或者另一个人获得了他们想要找到一个组合的尽可能多的时间（或者也许他们获得了更长的时间，但不是无限的时间？） 。也许一个用户点击“多卖3张卡”会给其他用户一些中等的时间来选择一个不罚的组合？您将需要弄清楚如何使用Timer来完成这些有时间限制的事情。